# 07 数据结构02

## 1. 算法

算法的特性：

- 有穷性
- 确定性
- 输入>0
- 输出>1
- 有效性：每个步骤都能有效执行，并得到确定的结果

## 2. 复杂度

时间复杂度：
$$
O(1)\lt O(log_2n)\lt O(n)\lt O(nlog_2n)\lt O(n^2)\lt O(n^3)\lt O(2^n)
$$
空间复杂度：

- 运行过程中临时占用存储空间大小的度量

## 3. 查找

- 顺序查找：
  - 时间复杂度：$(n+1)\div 2$，O(n)
  - 空间复杂度：O(1)
- 二分查找：向下取整，已经比过的不加入下一个区间
  - 时间复杂度：比较次数最多$[log_2n]+1$，复杂度$O(log_2n)$



## 4. 散列表

散列查找使用的转换函数称为散列函数

- 线性探测法
- 伪随机数法



## 5. 排序

- 稳定性
- 内排序or外排序

分类：

- 插入类：

  直接插入、希尔

- 交换类：

  冒泡、快速

- 选择类：

  简单选择、堆排序

- 归并排序

- 基数排序



### 5.1 直接插入

数组中的数据分为两个区间，**已排序区间和未排序区间**。是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

**原地：**不涉及辅助空间$O(1)$

**稳定：**相同元素可以指定顺序，后面出现的放在后面

**复杂度：**

* 最好情况（已经有序），需要一次遍历$O(n)$
* 最坏情况，需要n次遍历，$O(n^2)$

### 5.2 希尔排序

希尔排序目的为了加快速度改进了插入排序，对待排序的元素进行分组，对组内元素做排序，之后再分组，再排序，最后微调。

本质上是一种**分组插入排序方法**。

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

**原地：**不涉及辅助空间$O(1)$

**稳定：**不稳定，分组可能打乱顺序

**复杂度：**

* 最好情况（已经有序），需要一次遍历$O(n)$
* 最坏情况，$O(n^{1.3})$



### 5.3 直接选择

在所有元素中选出排序码最小的记录，把它与第一个记录交换，然后再选最小的，跟第二个交换……

原地：可以不使用辅助空间，$O(1)$

稳定：选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏 了稳定性。

复杂度：

* 最好情况（已经有序），需要遍历，然后分组对比$O(n^2)$
* 最坏情况，$O(n^2)$

### 5.4 堆排序

有n个序列$\{K_1,K_2,...K_n \}$，满足以下关系，称之为堆：

- 大顶堆：$\{k_i \ge k_{2i}, k_i \ge k_{2i+1}\}$
- 小顶堆：$\{k_i \le k_{2i}, k_i \le k_{2i+1} \}$

小顶堆：每一个孩子节点都比父节点大

堆排序：堆顶元素永远是最小（大）的

🌰：初建堆，A={1,3,4,5,7,2,6,8,0}

1. 按照顺序建立完全二叉树
2. 局部调整叶子节点，跟最大**子节点**交换位置
3. 调整层节点，递归交换位置

```
      1					 1					1					1
     / \				/ \				   / \				   / \
    3   4			   3   6			  8   6				  8   6
   / \ / \			  / \ / \			 / \ / \			 / \ / \
  5  7 2  6			 8  7 2  4			3  7 2  4			5  7 2  4
 / \				/ \                / \				   / \
8   0			   5   0			  5   0				  3   0
     (1)				(2)					(3)					(4)

      8					 8
     / \				/ \
    1   6			   7   6
   / \ / \			  / \ / \
  5  7 2  4			 5  1 2  4
 / \				/ \
3   0			   4   0
     (5)				(6)
```

取走堆顶元素，用完全二叉树最后一个叶子节点代替。

稳定性：不稳定。

**复杂度：**

* 初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，



### 5.5 冒泡

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。

**原地：**不涉及辅助空间$O(1)$

**稳定：**相同元素不必交换，稳定

**复杂度：**

* 最好情况（已经有序），需要一次遍历$O(n)$
* 最坏情况，需要n次遍历，$O(n^2)$



### 5.6 快排

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 **pivot（分区点）**。

我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。（使用数组的交换，减少复杂度）

然后递归的处理左右两个区间的数。

快排使用了分治的思想

**原地：**不涉及辅助空间$O(1)$

**稳定：**分区涉及到**交换**的操作，两个相同元素的位置可能会改变

**复杂度：**

- 平均情况：$O(nlog_2n)$

* 最好情况（已经有序），需要一次遍历$O(n)$

* 最坏情况，包括已经排好序和没有排好序的情况，都一样的

  需要n次遍历，$O(n^2)$

```java
public class QuickSort {
    public static void QuickSort(int[] nums, int size) {
        QuickSortInner(nums, 0, size - 1);
    }

    public static void QuickSortInner(int[] nums, int start, int end) {
        if (start >= end) return;

        int pivot = partition(nums, start, end);
        QuickSortInner(nums, start, pivot - 1);
        QuickSortInner(nums, pivot + 1, end);
    }

    public static int partition(int[] nums, int start, int end) {
        int pivot = nums[end];
        int i = start;
        for (int j = start; j < end; j++) {
            if (nums[j] < pivot) {
                // i 是第一个大于p的下标
                if (i == j) {
                    ++i;
                } else {
                    int tmp = nums[i];
                    nums[i++] = nums[j];
                    nums[j] = tmp;
                }
            }
        }

        nums[end] = nums[i];
        nums[i] = pivot;

        return i;
    }
}
```



### 5.7 归并

归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

**原地：**合并的过程中需要**辅助数组**，这样就不是原地的。复杂度$O(n)$

**稳定：**在**合并**的过程中，可以保留元素的顺序

**复杂度：**

* 归并排序是先分解的，无论有序还是无序，都是$O(nlog_2n)$

<img src="06_数据结构.assets/归并.jpg" style="zoom: 43%;" />



### 5.8 基数排序

借助多关键字排序思想对单逻辑关键字进行排序。比如关键字按照个位、十位来分解。















