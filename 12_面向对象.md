# 12 面向对象

## 1. 基本概念

对象、类、抽象、封装、继承和泛化、多态、接口、消息、组件、模式和复用

## 2. 设计原则

单一职责原则：设计目的单一的类

开放-封闭原则：对扩展开放、对修改封闭

里氏替换原则：子类可以替换父类

依赖倒置原则：要依赖于抽象、而不是具体的实现；针对接口变成，不要针对实现编程

接口隔离规则：使用多个专门的接口笔使用单一的总接口要好

组合重用规则：要尽量使用组合，而不是继承关系达到重用目的

迪米特原则：一个对象应当对其它对象有尽可能少的了解

## 3. UML

构造块

- 事务：结构事务、行为事务、分组事务、注释事务
- 关系：依赖、关联、泛化、实现
- 图：

  - 静态图：类图、对象图、包图、组合结构图、构件图、部署图、制品图
- 动态图：用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图

规则

公共机制



序列图是场景的图形化补充，描述了以时间顺序组织的对象之间的交互活动。

状态图展现了一个状态机，它由状态、转换、事件和活动组成，对于接口、类和写作的行为建模很重要，强调对象行为的事件顺序。

通信图强调收发消息的对象的结构组织，强调参加交互的对象的组织。

活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。







## 4. 设计模式

架构模式：反映了开发软件系统做的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：最底层的模式，关注软件系统的设计与实现



**分类：**

- 创建型模式

  工厂方法模式、抽象工厂模式、原型模式、单例模式、构建器模式

- 结构型模式

  适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式

- 行为型模式：解决“类或对象之间的交互”的问题

  职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式



### 4.1 创建型模式：

| 名称         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| 抽象工厂模式 | 提供一个接口，可以创建一系列相关或者互相依赖的对象，而无需制定它们具体的类。 |
| 构建器模式   | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 |
| 工厂方法模式 | 定义一个创建对象的接口，担忧子类决定要实例化哪一个类，工厂方法使得子类实例化的过程推迟 |
| 原型模式     | 用原 型实例制定构建对象的类型，并且通过拷贝这个原型来创建新的对象 |
| 单例模式     | 保证一个类只有一个实例，并提供一个访问它的全局访问点         |

#### 4.1.1抽象工厂

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

#### 4.1.2 构建器

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

主要解决：在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

#### 4.1.3 工厂方法

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其**创建过程延迟到子类**进行。

```java
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

#### 4.1.4 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

> 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作**原型设计模式**（Prototype Design Pattern），简称**原型模式**。

#### 4.1.5 单例模式

保证类只有一个实例，并且添加一个全局访问点。

### 4.2 结构型模式：

设计如何组合类和对象获得更大的结构。

| 名称       | 简要说明                                                     |
| ---------- | ------------------------------------------------------------ |
| 适配器模式 | 将一个类的接口转换成用户希望得到的另一个接口                 |
| 桥接模式   | 类的抽象部分和它的实现部分分离开来，使它们可以独立的变化     |
| 组合模式   | 将对象组合成树型结构以表示整体-部分的层次 结构，用户对单个对象和组合对象的使用具有一致性 |
| 装饰模式   | 动态地给一个对象添加额外的职责，扩展了类的功能               |
| 外观模式   | 定义一个高层接口，为子系统的一组接口提供一个一致的外观，简化了使用 |
| 享元模式   | 提供大量细粒度对象共享的方法                                 |
| 代理模式   | 为其它对象提供一种代理以控制这个对象的访问                   |

#### 4.2.1 适配器模式

将一个类的接口转换成用户希望得到的另一个接口，使得原本不兼容的类可以一起工作。

举栗子：通过类属性的方式，在实现接口时添加额外的功能。

#### 4.2.2 桥接模式

桥接模式即**将抽象部分与它的实现部分分离开**来，使他们都可以独立变化。

> 抽象类：分析事物时，有共性的内容需要向上抽取，但是如果父类的方法功能和子类不同，那么这时就不抽取方法的主题，这样抽取的方法叫抽象方法。
>
> 接口类：Java中的接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。
>
> 区别：抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个接口。
>
> 相同：1. 都不能被实例化；2. 都可以包含抽象方法；
>
> 抽象类是在接口和实体类之间的一个桥梁。

一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。**桥**就是让这两个结构联系起来，可以独立的变化。

在程序运行时可以动态将**一个抽象化子类的对象和一个实现化子类的对象**进行组合。

举例子：抽象形状类和颜色实现类组合，生成不同形状和颜色的Shape。

#### 4.2.3 组合模式

是用于把一组相似的对象当作一个单一的对象。组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

举例子：组合模式专用于树形结构的场景：文件与目录，部门与员工

#### 4.2.4 装饰模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

主要解决继承关系过于复杂的问题，通过组合来替代继承。

举例子：Java IO类

#### 4.2.5 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

也可以叫门面模式：外观类根据请求的不同，实现不同的类。

外观形状类根据请求生成不同的形状。

#### 4.2.6 享元模式

尝试重用现有的同类**对象**，如果未找到匹配的对象，则创建新对象。

#### 4.2.7 代理模式

**代理模式**（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

原理和实现：在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。

动态代理：静态代理需要针对每个类都创建一个代理类；动态代理是运行的时候**动态地创建原始类对应的代理类**，然后在系统中用代理类替换掉原始类。

应用场景：开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理。

### 4.3 行为型模式：

解决“类或对象之间的交互”的问题

| 名称         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 责任链模式   | 将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求 |
| 命令模式     | 将一个请求封装为对象，                                       |
| 解释器模式   | 定义一个解释器，根据文法表示解释语言                         |
| 迭代器模式   | 提供一种方法来**顺序访问**一个聚合对象中各个元素，而不需要暴漏该对象的内部表示 |
| 中介者模式   | 中介对象封装一系列的对象交互，它使得各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象的交互 |
| 备忘录模式   | 不破坏封装性的前提下，捕获一个对象的内部状态并单独保存，以便恢复 |
| 观察者模式   | 定义对象间的一对多的依赖关系，当一个对象状态发生改变，所有对象都得到通知并更新 |
| 状态模式     | 允许一个对象在其内部状态改变时改变他的行为                   |
| 策略模式     | 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法独立与使用它的用户而变化 |
| 模板方法模式 | 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法结构即可重新定义算法的某些特定步骤 |
| 访问者模式   | 表示一个作用域某对象结构的各元素的操作，使得不改变各元素的前提下定义作用域这些元素的新操作 |

#### 4.3.1 责任链模式：

将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，链上的每个对象承担各自的职责。

举例子：根据日志的级别来打印日志，敏感级别过滤数据

#### 4.3.2 命令模式：

命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。

举例子：对买卖股票的请求进行封装，添加撤销、记录日志甚至事务

#### 4.3.3 解释器模式

解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。

举例子：接口告警规则解析，正则语法解析，SQL语法解析

#### 4.3.4 迭代器

提供一种方法可以顺序访问集合元素中的元素，相当于隐藏了集合对象的表示。

原理：迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。

#### 4.3.5 中介模式

中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。

举例子：为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。

#### 4.3.6 备忘录模式

在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

可以选择保存对象的某些参数，然后再将对象重新实例化。

#### 4.3.7 观察者模式

在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

也成为发布订阅模式，解耦了发布者和订阅者之间的关系。

举例子：新用户注册成功，发放不同的活动（对象），可以动态的添加、删除观察者

#### 4.3.8 状态模式

许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

举例子：马里奥可以变身为多种形态，看起来像是改变了类

#### 4.3.9 策略模式

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

类似于多态，相同的父类，不同的实现

#### 4.3.10 模板方法

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

这里的“算法”，我们可以理解为广义上的“业务逻辑”

一次性实现算法不变的部分，可变的部分延迟（给子类）实现。

#### 4.3.11 访问者模式

将作用于某种**数据结构**中的各元素的**操作**分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将数据的操作与数据结构进行分离。

举例子：医院医生开的**处方单**中包含多种药元素，查看它的划价员和药房工作人员对它的处理方式不同









