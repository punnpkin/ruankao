# 12 面向对象

## 1. 基本概念

对象、类、抽象、封装、继承和泛化、多态、接口、消息、组件、模式和复用

## 2. 设计原则

单一职责原则：设计目的单一的类

开放-封闭原则：对扩展开放、对修改封闭

里氏替换原则：子类可以替换父类

依赖倒置原则：要依赖于抽象、而不是具体的实现；针对接口变成，不要针对实现编程

接口隔离规则：使用多个专门的接口笔使用单一的总接口要好

组合重用规则：要尽量使用组合，而不是继承关系达到重用目的

迪米特原则：一个对象应当对其它对象有尽可能少的了解

## 3. UML

构造块

- 事务：结构事务、行为事务、分组事务、注释事务

- 关系：依赖、关联、泛化、实现

- 图：

  - 静态图：类图、对象图、包图、组合结构图、构件图、部署图、制品图

  - 动态图：用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图

规则

公共机制



## 4. 设计模式

架构模式：反映了开发软件系统做的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：最底层的模式，关注软件系统的设计与实现



**分类：**

- 创建型模式

  工厂方法模式、抽象工厂模式、原型模式、单例模式、构建器模式

- 结构型模式

  适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式

- 行为型模式

  职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式



**创建型模式：**

| 名称         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| 抽象工厂模式 | 提供一个接口，可以创建一系列相关或者互相依赖的对象，而无需制定它们具体的类。 |
| 构建器模式   | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 |
| 工厂方法模式 | 定义一个创建对象的接口，担忧子类决定要实例化哪一个类，工厂方法使得子类实例化的过程推迟 |
| 原型模式     | 用原 型实例制定构建对象的类型，并且通过拷贝这个原型来创建新的对象 |
| 单例模式     | 保证一个类只有一个实例，并提供一个访问它的全局访问点         |



**结构型模式：**

| 名称       | 简要说明                                                     |
| ---------- | ------------------------------------------------------------ |
| 适配器模式 | 将一个类的接口转换成用户希望得到的另一个接口                 |
| 桥接模式   | 类的抽象部分和它的实现部分分离开来，使它们可以独立的变化     |
| 组合模式   | 将对象组合成树型结构以表示整体-部分的层次 结构，用户对单个对象和组合对象的使用具有一致性 |
| 装饰模式   | 动态地给一个对象添加额外的职责，扩展了类的功能               |
| 外观模式   | 定义一个高层接口，为子系统的一组接口提供一个一致的外观，简化了使用 |
| 享元模式   | 提供大量细粒度对象共享的方法                                 |
| 代理模式   | 为其它对象提供一种代理以控制这个对象的访问                   |



**行为型模式：**

| 名称         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 责任链模式   | 将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求 |
| 命令模式     | 将一个请求封装为对象，                                       |
| 解释器模式   | 定义一个解释器，根据文法表示解释语言                         |
| 迭代器模式   | 提供一种方法来**顺序访问**一个聚合对象中各个元素，而不需要暴漏该对象的内部表示 |
| 中介者模式   | 中介对象封装一系列的对象交互，它使得各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象的交互 |
| 备忘录模式   | 不破坏封装性的前提下，捕获一个对象的内部状态并单独保存，以便恢复 |
| 观察者模式   | 定义对象间的一对多的依赖关系，当一个对象状态发生改变，所有对象都得到通知并更新 |
| 状态模式     | 允许一个对象在其内部状态改变时改变他的行为                   |
| 策略模式     | 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法独立与使用它的用户而变化 |
| 模板方法模式 | 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法结构即可重新定义算法的某些特定步骤 |
| 访问者模式   | 表示一个作用域某对象结构的各元素的操作，使得不改变各元素的前提下定义作用域这些元素的新操作 |











