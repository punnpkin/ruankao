# 03 数据库系统（重要）

## 0. 前言

数据库模式、ER模型、关系代数和元组演算、规范化控制、并发控制、数据库 完整性约束、分布式数据库、数据仓库和数据挖掘

## 1. 三级模式-两级映射

<img src="03_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.assets/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" style="zoom:67%;" />

[参考](https://blog.csdn.net/mcb520wf/article/details/91047683)

三级模式

- **用户级**

  外模式，它是某个或某几个用户所看到的数据库的**数据视图**，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用**数据操纵语言(Data Manipulation Language，DML)**对这些数据记录进行操作。

- **概念级**

  概念模式：它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的**数据模式描述语言(Data Description Language，DDL)**来描述、定义的。

- **物理级**

  内模式：它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。

总之，数据按**外模式的描述提供给用户；按内模式的描述存储在磁盘上；而概念模式提供了连接这两级模式的相对稳定的中间层**，并使得两级中任意一级的改变都不受另一级的牵制。

两级映射

数据库系统在三级模式之间提供了两级映像：模式/内模式的映像、外模式/模式的映像。

- 模式/内模式的映像：实现概念模式到内模式之间的相互转换；
- 外模式/模式的映像：实现外模式到概念模式之间的相互转换。

数据的独立性是指数据与程序独立，将数据的定义从程序中分离出来，由DBMS（数据库管理系统）负责数据的存储，数据的独立性包括数据的**物理独立性**和数据的**逻辑独立性**。

什么是数据的物理独立性？

答：数据的物理独立性是指当**数据库的内模式发生改变时，数据的的逻辑结构不变**。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是，为了保证应用程序能够正确执行，**需要修改概念模式/内模式之间的映像**。

什么是数据的逻辑独立性？

答：数据的逻辑独立性是指**用户的应用程序与数据库结构是相互独立的**。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，**需要修改外模式/概念模式之间的映像**。

## 2. 数据库的设计过程

[参考](https://blog.csdn.net/qq_43333395/article/details/105876760)

1. **需求设计：**分析用户的需求，包括数据、功能和性能需求；
2. **概念结构设计：**主要采用E-R模型进行设计；
3. **逻辑结构设计：**通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
4. **物理结构设计：**主要是为所设计的数据库选择合适的存储结构和存取路径；
5. **数据库实施：**数据库的实施：包括编程、测试和试运行；
6. **数据库的运行和维护：**系统的运行与数据库的日常维护。

## 3. ER图

方框表示**实体**，椭圆表示**属性**，菱形表示**联系**

- 实体：是一个数据对象，指应用中可以区别的客观存在的事物；
- 联系：表示一个或多个实体之间的关联关系；
- 属性：实体的某一特性称为属性。

ER图集成：

- 多个局部ER图一次集成
- 逐步集成：用累加的方式，一次集成两个

属性冲突：

- 属性冲突
- 命名冲突
- 结构冲突

**关系模型：**用二维表的形式表示实体和实体间联系的数据模型

- 关系模型中，字段称为属性，字段值称为属性值；
- 关系模式名是R。记录称为元组，元组的集合称为关系或实例；

**ER模型与关系模型的转化**

- 若实体间的联系是1:1，可以再两个实体类型转换成的两个关系模式中**任意的一个关系模式的属性加入另一个关系模式的键和联系类型的属性**。
- 若实体间的联系是1:n，则在n端的实体类型转换成的关系模式中加入1端实体类型的键和联系类型的属性。
- 若实体间的联系是m:n，则将**联系类型也转换成关系模式**，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合。

三个以上实体间的一个多元联系



**例题：**

在数据库逻辑结构的设计中，将E-R模型转为关系模型应遵循相关的原则。对于三个不同实体集和它们之间的多对多联系m: n: p，最少课转换为（）个关系模式。

![例题](./03_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.assets/ER%E5%9B%BE%E4%BE%8B%E9%A2%98.png)

A、B、C加上中间的联系，一共四个



## 4. 关系代数

并、交、差、笛卡尔积、投影、选择、联结

<img src="./03_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.assets/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.png" style="zoom:67%;" />

<img src="./03_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.assets/连接.png" style="zoom:67%;" />

## 5. 规范化理论

### 5.1 函数依赖

[参考](https://blog.csdn.net/Shishishi888/article/details/90113660)

关系模式中的各属性之间相互依赖、相互制约的联系称为数据依赖。数据依赖一般分为函数依赖、[多值依赖](https://blog.csdn.net/Shishishi888/article/details/90144652)和连接依赖。其中函数依赖是最重要的数据依赖。

**函数依赖**（Functional Dependency，FD）是关系模式中属性之间的一种逻辑依赖关系。

例如，在一个有关学生的关系模式SCD（属性SNo，SN，Age，Dept，MN，CNo，Score分别代表学生证号，学生姓名，年龄，所属院系，院系主人姓名，选修课程号，分数）中，属性SNo与SN、Age和Dept之间都有一种依赖关系。由于一个SNo只对应一个学生，而一个学生只能属于一个系，所以当SNo的值确定之后，SN、Age、Dept的值也随之被唯一地确定了。在这里,我们说SNo决定函数(SN, Age, Dept)，或者说(SN, Age, Dept)函数依赖于SNo。

函数依赖有**部分依赖**和**传递函数**依赖。

### 5.2 键

- **码=超键：**唯一标识元组

- **候选码=候选键：**消除冗余属性

- **主码=主键：**候选键中任意一个

- **外键：** 其它关系的主键

- **主属性：**包含在任一候选码中的属性称主属性，主属性是候选码所有属性的并集

  **非主属性：**不包含在候选码中的属性称为非主属性。

- **全码：**当所有的属性共同构成一个候选码时，这时该候选码为全码。

**候选键的求解：**

- 关系模式的函数依赖关系用“有向图”的方式表示；
- 找出**入度为0**的属性，并以该属性集合为起点，尝试遍历有向图。所能全部遍历，则为**候选键**；
- 如果入度为0的节点不满足，则尝试寻找将中间节点**并入入度为0的属性集**中，然后完成遍历。

仓库（仓库名、管理员、物品名、数量）

仓库，管理员一一对应；一个仓库可以存多种物品，一种物品可以存放多个仓库

- 仓库名<->管理员

- （仓库名，物品名）->（管理员，数量） 

- （管理员，物品名）->（仓库名，数量）

候选键：（仓库名，物品名）（管理员，物品名）

主属性：（仓库名，管理员，物品名）

非主属性：（数量）

### 5.3 模式分解

- 保持函数依赖
- 无损分解

例题🌰：

关系模式：成绩（学号、姓名、课程号、课程名、分数）

函数依赖：学号→姓名，课程号→课程名，（学号，课程号）→分数

分解结果：

- 成绩（学号，课程号，分数）
- 学生（学号，姓名）
- 课程（课程号，课程名）

分解结果可以还原关系模式，可以做无损分解

## 6. 并发控制-事务

事务ACID

- **原子性：**一个原子事务要么完整执行，要么干脆不执行。
- **一致性：**一致性代表了底层数据存储的完整性。例如，在一次转账过程中，从某一账户中扣除的金额必须与另一账户中存入的金额相等。
- **隔离性：**隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。
- **持久性：**持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。

事务的隔离级别

* **读未提交：**一个事务在没有提交时候，他的变更就可以被其它事务看到。
* **读提交：**一个事务提交之后，才能。。。
* **可重复读：**事务执行时的能看到的数据，总是跟事务在启动时看到数据是一样的；
* **串行化：**对于同一行记录，加写锁和读锁。

引发的问题：

- **脏读：**脏读又称无效数据读出（读出了脏数据）。一个事务读取**另外一个事务还没有提交**的数据叫脏读。
- **不可重复读：**不可重复读是指在**同一个事务**内，两次相同的查询返回了不同的结果。
- **幻读：**幻读也是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。

## 7. 完整性约束

用户提高数据的可靠性

[参考](https://blog.csdn.net/weixin_37657720/article/details/87441287)

- **实体完整性：**规定表的每一行在表中是惟一的实体；
- **域完整性：**是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定；
- **参照完整性：**两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散；
- **用户自定义完整性：**不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。

**触发器：**更加复杂的要求



## 8. 数据库安全

- **用户表示和鉴定：**最外层的安全保护措施，保护用户账户，口令等；
- **存取控制：**对用户的授权，包括操作类型和数据对象的权限；
- **密码存储和传输：**对远程终端信息用密码传输；
- **视图的保护：**对视图进行授权；
- **审计：**记录用户对数据库的所有操作。



## 9. 数据备份

- **冷备份：**关闭数据库，备份数据；

- **热备份：**数据库运行的过程中备份，缺点是不能出错（后果较为严重）。

完全备份，差量备份（上一次**完全备份**后），增量备份

一种备份策略

> 如果系统在星期四的早晨发生故障，丢失大批数据，那么现在就需要将系统恢复到星期三晚上的状态。这时管理员需要首先找出星期一的那盘完全备份磁带进行系统恢复，然后再找出星期二的磁带来恢复星期二的数据，然后在找出星期三的磁带来恢复星期三的数据。

|  日  |  一  |  二  |  三  |  四  |  五  |  六  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  全  |  增  |  增  |  增  |  差  |  增  |  增  |

- 可预期故障：预先设置Rollback回滚
- 不可预期：DBMS通过日志回退
- 系统故障：检查点回府
- 介质故障：一般使用日志重做业务

## 10. 数据仓库

- 面向主题而不是面向应用
- 集成的
- 相对稳定的（数据一般不会修改）
- 反映历史变化的

## 11. 反规范化

增加冗余列

增加派生列

重新组表

分割表

## 12. 大数据

数据量，速度，多样性，低价值





----



## 13 范式

[参考](https://blog.csdn.net/u014458048/article/details/56678698)

超键：唯一表示元组的属性或者属性集

候选键：不含有多余属性的超键称为候选键

主键：用户选作元组标识的键称为主键

外键：模式R中的属性K是其它模式的主键



部份依赖：若$X\rarr Y$，且有$X'$是$X$的真子集，存在$X'\rarr Y$，则$Y$部分依赖$X$

完全依赖：若$X\rarr Y$，且有$X'$是$X$的真子集，存在$X'!\rarr Y$，则$Y$完全依赖$Y$

传递依赖：$X\rarr Y, Y\rarr Z$，



1NF：属性不可再分，任何一个关系数据库必须满足第一范式

2NF：数据表每一个实例或者行必须被唯一标识（完全依赖）

3NF：非主属性不传递依赖于候选键，🌰：列A依赖于B，B依赖于主键

BCNF：不存在任何字段对任一候选键传递依赖：

- 所有非主属性对每一个码都是完全函数依赖；
- 所有的主属性对于每一个不包含它的码，也是完全函数依赖；
- 没有任何属性完全函数依赖于非码的任意一个组合。



🌰：仓库管理关系表为Storehouse Manage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。

(仓库ID, 存储物品ID) →(管理员ID, 数量)

(管理员ID, 存储物品ID) → (仓库ID, 数量)

(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

(仓库ID) → (管理员ID)

(管理员ID) → (仓库ID)

即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。



---

## 14 索引

一个🌰：

```mysql
CREATE TABLE `award` (
   `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',
   `aty_id` varchar(100) NOT NULL DEFAULT '' COMMENT '活动场景id',
   `nickname` varchar(12) NOT NULL DEFAULT '' COMMENT '用户昵称',
   `is_awarded` tinyint(1) NOT NULL DEFAULT 0 COMMENT '用户是否领奖',
   `award_time` int(11) NOT NULL DEFAULT 0 COMMENT '领奖时间',
   `account` varchar(12) NOT NULL DEFAULT '' COMMENT '帐号',
   `password` char(32) NOT NULL DEFAULT '' COMMENT '密码',
   `message` varchar(255) NOT NULL DEFAULT '' COMMENT '获奖信息',
   `created_time` int(11) NOT NULL DEFAULT 0 COMMENT '创建时间',
   `updated_time` int(11) NOT NULL DEFAULT 0 COMMENT '更新时间',
   PRIMARY KEY (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='获奖信息表';
```



MySQL的索引分为单列索引（主键索引，唯一索引，普通索引）和组合索引

- 单列索引：一个索引只包含一个列,一个表可以有多个单列索引

- 组合索引：一个组合索引包含两个或两个以上的列



聚簇索引：按照每张表的主键构建一颗B+树，同时叶子节点中存放的就是整张表的行记录

将索引和数据放到了一起，找到索引也就找到了数据。

如果对数据库的一张表创建聚簇索引，意味着重新确定表的物理顺序，即改变数据库的内模式。

[参考][https://blog.csdn.net/wifi1234/article/details/18912843]

- 外模式：是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。

- 模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。

- 内模式：也叫存储模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式



## 15. Armstrong公理系统

[链接](https://blog.csdn.net/weixin_44611096/article/details/105792748)

> 数据库专家Armstrong等提出一组定义和推理规则，并形成了一个有效而完备的理论体系，即Armstrong公理系统。

通俗的写：【X】【Y】【Z】都代表关系模式的子集

- 自反律：若Y是X的一部分（子集），则X→Y
- 增广律：如果X→Y，则XZ→YZ（X∪Z→Y∪Z）
- 传递律：如果X→Y，Y→Z，则X→Z

推理：

- 合并规则：若X→Y，X→Z，则X→YZ
- 伪传递规则：若X→Y，WY→Z，则XW→Z
- 分解性规则：若X→Y，Z是Y的一部分（子集），则X→Z

